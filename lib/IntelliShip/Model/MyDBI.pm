package IntelliShip::Model::MyDBI;

use strict;
use Math::BaseCalc;
use IntelliShip::MyConfig;

use base 'Catalyst::Model::DBIC::Schema';

__PACKAGE__->config(
    schema_class => 'IntelliShip::SchemaClass',

    connect_info => {
           dsn      => 'dbi:Pg:dbname=aos_intelliship;host=' . IntelliShip::MyConfig->getDatabaseHost . ';port=5432;',
#          dsn      => 'dbi:Pg:dbname=aos_intelliship;host=localhost;port=5432;',
           user     => 'webuser',
           password => 'Byt#Yu2e',
           disable_sth_caching => 1,
           AutoCommit => 1
    }
);

sub dbh                { my $self = shift; return $self->storage->dbh; }
sub sth                { my $self = shift; if (@_) { $self->{STH_HANDLE} = shift }; return $self->{STH_HANDLE}; }
sub numrows            { my $self = shift; if (@_) { $self->{STH_NUMROWS} = shift }; return $self->{STH_NUMROWS}; }
sub query_data         { my $self = shift; if (@_) { $self->{TABLE_ARRAY} = shift }; return $self->{TABLE_ARRAY}; }
sub query_field_number { my $self = shift; if (@_) { $self->{QUERY_FIELD_NUMBER} = shift }; return $self->{QUERY_FIELD_NUMBER}; }

sub select
	{
	my $self = shift;
	my $sql = shift;

	my $dbh = $self->storage->dbh;
	my $sth = $dbh->prepare($sql);

	unless ($sth->execute)
		{
		print STDERR "\nQuery failed to execute.";
		print STDERR "\nFull query: $sql";
		return undef;
		}

	unless (my $names = $sth->{NAME})
		{
		print STDERR "\nQuery did not return field names";
		return undef;
		}

	my $obref = {};
	bless($obref);

	my $tbl_ary_ref = $sth->fetchall_arrayref;
	$obref->query_data($tbl_ary_ref);
	$obref->numrows(scalar @$tbl_ary_ref);
	$obref->sth($sth);

	return $obref;
	}

sub fetchrow
	{
	my $self = shift;
	my $rowno = shift;
	my $return_hash = {};

	return undef unless $rowno >= 0;

	my $row_data_array = $self->query_data->[$rowno];
	my $field_count = $self->query_field_number;

	return undef unless $row_data_array;

	if (!$field_count)
		{
		$field_count = scalar @$row_data_array;
		$self->query_field_number($field_count)
		}

	for (my $i = 0; $i < $field_count; $i++)
		{
		my $fieldname = $self->sth->{NAME}->[$i];
		$return_hash->{$fieldname} = $row_data_array->[$i];
		}

	if ($rowno == $self->numrows)
		{
		$self->sth->finish;
		}

	return $return_hash;
	}

sub get_token_id
	{
	my $self = shift;
	my $sth = $self->select("SELECT to_char(timestamp 'now', 'YYYYMMDDHH24MISS')||lpad(CAST(nextval('master_seq') AS text),6,'0') AS rawtoken");
	my $RawToken = $sth->fetchrow(0)->{'rawtoken'} if $sth->numrows;
	## Convert our 20 digit token to a 13 digit token
	my $BaseCalc = new Math::BaseCalc(digits => [0..9,'A'..'H','J'..'N','P'..'Z']);
	my $SeqID = $BaseCalc->to_base($RawToken);
	return $SeqID;
	}

sub sequence_number
	{
	my $self = shift;
	my $SeqName = shift;
	my $sth = $self->select("SELECT nextval('$SeqName')");
	my $SeqID = $sth->fetchrow(0)->{'nextval'};
	return $SeqID;
	}

=head1 NAME

IntelliShip::Model::MyDBI - Catalyst DBIC Schema Model

=head1 SYNOPSIS

See L<IntelliShip>

=head1 DESCRIPTION

L<Catalyst::Model::DBIC::Schema> Model using schema L<IntelliShip::SchemaClass>

=head1 GENERATED BY

Catalyst::Helper::Model::DBIC::Schema - 0.61

=head1 AUTHOR

root

=head1 LICENSE

This library is free software, you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

1;
